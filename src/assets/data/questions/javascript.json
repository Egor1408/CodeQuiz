{
"language": "javascript",
"sections": [
	{
	"id": "basics",
	"title": "Основы",
	"questions": [
		{
		"id": "basics-1",
		"question": "Что выведет следующий код: console.log(typeof null)?",
		"options": [
			{
			"id": "a",
			"text": "null"
			},
			{
			"id": "b",
			"text": "object"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "boolean"
			}
		],
		"correctAnswerId": "b",
		"explanation": "typeof null возвращает 'object' - это известная особенность JavaScript, которая является багом в языке."
		},
		{
		"id": "basics-2",
		"question": "Какое значение имеет переменная после выполнения: let x = 10; x = '20';?",
		"options": [
			{
			"id": "a",
			"text": "10"
			},
			{
			"id": "b",
			"text": "20"
			},
			{
			"id": "c",
			"text": "'20'"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "c",
		"explanation": "JavaScript - язык с динамической типизацией, переменная x сначала была числом 10, затем стала строкой '20'."
		},
		{
		"id": "basics-3",
		"question": "Что такое hoisting в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Поднятие объявлений переменных и функций в начало области видимости"
			},
			{
			"id": "b",
			"text": "Оптимизация кода компилятором"
			},
			{
			"id": "c",
			"text": "Удаление неиспользуемого кода"
			},
			{
			"id": "d",
			"text": "Кэширование результатов функций"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Hoisting - это механизм JavaScript, при котором объявления переменных (var) и функций поднимаются в начало их области видимости."
		},
		{
		"id": "basics-4",
		"question": "Чему равно значение: 0.1 + 0.2 === 0.3?",
		"options": [
			{
			"id": "a",
			"text": "true"
			},
			{
			"id": "b",
			"text": "false"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Из-за особенностей представления чисел с плавающей точкой в JavaScript, 0.1 + 0.2 не равно точно 0.3, а примерно 0.30000000000000004."
		},
		{
		"id": "basics-5",
		"question": "Какая разница между == и === в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "== сравнивает значения с приведением типов, === сравнивает значения и типы"
			},
			{
			"id": "c",
			"text": "== сравнивает ссылки, === сравнивает значения"
			},
			{
			"id": "d",
			"text": "== работает только с числами, === работает со всеми типами"
			}
		],
		"correctAnswerId": "b",
		"explanation": "== выполняет приведение типов перед сравнением (например, '5' == 5 вернет true), а === сравнивает без приведения типов ('5' === 5 вернет false)."
		},
		{
		"id": "basics-6",
		"question": "Что такое truthy и falsy значения в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Типы данных"
			},
			{
			"id": "b",
			"text": "Значения, которые при приведении к boolean становятся true (truthy) или false (falsy)"
			},
			{
			"id": "c",
			"text": "Встроенные функции JavaScript"
			},
			{
			"id": "d",
			"text": "Способ объявления переменных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Falsy значения: false, 0, -0, 0n, '', null, undefined, NaN. Все остальные значения являются truthy и приводятся к true в булевом контексте."
		},
		{
		"id": "basics-7",
		"question": "Что выведет: console.log([] + [] + 'foo'.split(''));",
		"options": [
			{
			"id": "a",
			"text": "['f', 'o', 'o']"
			},
			{
			"id": "b",
			"text": "'f,o,o'"
			},
			{
			"id": "c",
			"text": "'foo'"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Пустой массив при конкатенации преобразуется в пустую строку ''. split('') разбивает строку на массив ['f', 'o', 'o'], который при конкатенации становится строкой 'f,o,o'."
		},
		{
		"id": "basics-8",
		"question": "Что такое NaN в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Сокращение от 'Not a Number' - значение, представляющее нечисловое значение"
			},
			{
			"id": "b",
			"text": "Тип данных"
			},
			{
			"id": "c",
			"text": "Встроенная функция"
			},
			{
			"id": "d",
			"text": "Способ объявления переменных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "NaN (Not a Number) - это значение, которое представляет результат некорректной математической операции. Интересно, что typeof NaN === 'number', и NaN !== NaN (true)."
		},
		{
		"id": "basics-9",
		"question": "Что такое scope (область видимости) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Контекст, определяющий доступность переменных, функций и объектов в определенной части кода"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Scope определяет видимость переменных и функций. В JavaScript есть глобальная область видимости, функциональная (function scope) для var, и блочная (block scope) для let и const."
		},
		{
		"id": "basics-10",
		"question": "Что выведет: console.log(typeof undefined);",
		"options": [
			{
			"id": "a",
			"text": "undefined"
			},
			{
			"id": "b",
			"text": "object"
			},
			{
			"id": "c",
			"text": "null"
			},
			{
			"id": "d",
			"text": "string"
			}
		],
		"correctAnswerId": "a",
		"explanation": "typeof undefined возвращает строку 'undefined'. Это единственный случай, когда typeof возвращает название типа, совпадающее с самим значением."
		},
		{
		"id": "basics-11",
		"question": "Что такое strict mode в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Режим, который делает код более строгим, запрещая некоторые небезопасные операции"
			},
			{
			"id": "b",
			"text": "Способ объявления переменных"
			},
			{
			"id": "c",
			"text": "Встроенная функция"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Strict mode ('use strict') - это режим, который делает JavaScript более строгим, запрещая использование необъявленных переменных, дублирование параметров, и делает this равным undefined в функциях без контекста."
		},
		{
		"id": "basics-12",
		"question": "Что выведет: console.log('5' - 3);",
		"options": [
			{
			"id": "a",
			"text": "'53'"
			},
			{
			"id": "b",
			"text": "2"
			},
			{
			"id": "c",
			"text": "NaN"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "При операции вычитания JavaScript пытается преобразовать операнды в числа. '5' преобразуется в 5, поэтому '5' - 3 = 2. В отличие от сложения, где происходит конкатенация строк."
		}
	]
	},
	{
	"id": "functions",
	"title": "Функции",
	"questions": [
		{
		"id": "functions-1",
		"question": "Что такое замыкание (closure) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Функция, которая имеет доступ к переменным из внешней области видимости"
			},
			{
			"id": "c",
			"text": "Способ вызова функции"
			},
			{
			"id": "d",
			"text": "Встроенная функция JavaScript"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Замыкание - это функция, которая имеет доступ к переменным из внешней (охватывающей) области видимости, даже после того, как внешняя функция завершила выполнение."
		},
		{
		"id": "functions-2",
		"question": "Что выведет код: function test() { return this; } console.log(test());",
		"options": [
			{
			"id": "a",
			"text": "undefined"
			},
			{
			"id": "b",
			"text": "null"
			},
			{
			"id": "c",
			"text": "window (в браузере) или global (в Node.js)"
			},
			{
			"id": "d",
			"text": "Сама функция test"
			}
		],
		"correctAnswerId": "c",
		"explanation": "В обычном режиме (не strict mode) this в функции, вызванной без контекста, указывает на глобальный объект (window в браузере, global в Node.js)."
		},
		{
		"id": "functions-3",
		"question": "В чем разница между function declaration и function expression?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "Function declaration поднимается (hoisted), function expression - нет"
			},
			{
			"id": "c",
			"text": "Function expression поднимается, function declaration - нет"
			},
			{
			"id": "d",
			"text": "Function declaration нельзя вызывать, function expression можно"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Function declaration поднимается в начало области видимости и может быть вызвана до объявления. Function expression создается только при выполнении строки кода."
		},
		{
		"id": "functions-4",
		"question": "Что такое IIFE (Immediately Invoked Function Expression)?",
		"options": [
			{
			"id": "a",
			"text": "Функция, которая вызывается автоматически при загрузке страницы"
			},
			{
			"id": "b",
			"text": "Функция, которая выполняется немедленно после определения"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Асинхронная функция"
			}
		],
		"correctAnswerId": "b",
		"explanation": "IIFE - это функция, которая выполняется сразу же после создания. Синтаксис: (function() { ... })() или (function() { ... }())."
		},
		{
		"id": "functions-5",
		"question": "Что выведет: const arrow = () => { return this; }; console.log(arrow());",
		"options": [
			{
			"id": "a",
			"text": "undefined"
			},
			{
			"id": "b",
			"text": "window или global"
			},
			{
			"id": "c",
			"text": "this берется из лексического контекста (где функция определена)"
			},
			{
			"id": "d",
			"text": "null"
			}
		],
		"correctAnswerId": "c",
		"explanation": "Стрелочные функции не имеют собственного this. Они наследуют this из окружающего лексического контекста, где они были определены."
		},
		{
		"id": "functions-6",
		"question": "Что такое callback функция?",
		"options": [
			{
			"id": "a",
			"text": "Функция, которая вызывается после завершения другой функции"
			},
			{
			"id": "b",
			"text": "Функция, передаваемая как аргумент в другую функцию для последующего вызова"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Способ объявления функции"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Callback - это функция, которая передается как аргумент в другую функцию и вызывается позже, обычно после завершения асинхронной операции или события."
		},
		{
		"id": "functions-7",
		"question": "Что такое рекурсия в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Механизм, при котором функция вызывает саму себя"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Рекурсия - это техника программирования, при которой функция вызывает саму себя. Важно иметь условие выхода (base case), иначе возникнет бесконечная рекурсия."
		},
		{
		"id": "functions-8",
		"question": "Что такое arguments объект в функции?",
		"options": [
			{
			"id": "a",
			"text": "Массив всех аргументов, переданных в функцию"
			},
			{
			"id": "b",
			"text": "Псевдомассив, содержащий все аргументы, переданные в функцию"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "arguments - это псевдомассив (не настоящий массив), доступный внутри обычных функций (не стрелочных), содержащий все переданные аргументы. Можно преобразовать в массив через Array.from(arguments)."
		},
		{
		"id": "functions-9",
		"question": "Что такое функция высшего порядка (higher-order function)?",
		"options": [
			{
			"id": "a",
			"text": "Функция, которая работает быстрее других"
			},
			{
			"id": "b",
			"text": "Функция, которая принимает другие функции как аргументы или возвращает функцию"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Способ объявления функции"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Функция высшего порядка - это функция, которая принимает другие функции как аргументы или возвращает функцию. Примеры: map, filter, reduce, setTimeout."
		},
		{
		"id": "functions-10",
		"question": "Что такое каррирование (currying) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Техника преобразования функции с несколькими аргументами в последовательность функций с одним аргументом"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Каррирование - это техника, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает один аргумент. Пример: const add = a => b => a + b;"
		},
		{
		"id": "functions-11",
		"question": "Что такое мемоизация (memoization)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Техника оптимизации, при которой результаты вычислений функции кэшируются для повторного использования"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Мемоизация - это техника оптимизации, при которой результаты дорогих вычислений функции сохраняются в кэше, и при повторном вызове с теми же аргументами возвращается закэшированный результат."
		},
		{
		"id": "functions-12",
		"question": "Что выведет: function foo() { return arguments.length; } console.log(foo(1, 2, 3));",
		"options": [
			{
			"id": "a",
			"text": "0"
			},
			{
			"id": "b",
			"text": "3"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "arguments.length возвращает количество аргументов, переданных в функцию. В данном случае передано 3 аргумента (1, 2, 3), поэтому результат будет 3."
		}
	]
	},
	{
	"id": "arrays-objects",
	"title": "Массивы и объекты",
	"questions": [
		{
		"id": "arrays-objects-1",
		"question": "Что выведет: const arr = [1, 2, 3]; arr[10] = 10; console.log(arr.length);",
		"options": [
			{
			"id": "a",
			"text": "3"
			},
			{
			"id": "b",
			"text": "4"
			},
			{
			"id": "c",
			"text": "11"
			},
			{
			"id": "d",
			"text": "10"
			}
		],
		"correctAnswerId": "c",
		"explanation": "При присваивании значения по индексу 10, длина массива становится 11 (индексы от 0 до 10). Элементы с индексами 3-9 будут undefined."
		},
		{
		"id": "arrays-objects-2",
		"question": "В чем разница между методами map() и forEach()?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "map() возвращает новый массив, forEach() возвращает undefined"
			},
			{
			"id": "c",
			"text": "forEach() возвращает новый массив, map() возвращает undefined"
			},
			{
			"id": "d",
			"text": "map() изменяет исходный массив, forEach() создает новый"
			}
		],
		"correctAnswerId": "b",
		"explanation": "map() создает и возвращает новый массив с результатами вызова функции для каждого элемента. forEach() просто выполняет функцию для каждого элемента и возвращает undefined."
		},
		{
		"id": "arrays-objects-3",
		"question": "Что такое деструктуризация (destructuring) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Удаление элементов из массива"
			},
			{
			"id": "b",
			"text": "Способ извлечения значений из массивов или объектов в отдельные переменные"
			},
			{
			"id": "c",
			"text": "Способ создания объектов"
			},
			{
			"id": "d",
			"text": "Метод работы с DOM"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Деструктуризация позволяет извлекать значения из массивов или свойств объектов в отдельные переменные. Пример: const [a, b] = [1, 2]; или const {name, age} = person;"
		},
		{
		"id": "arrays-objects-4",
		"question": "Что выведет: const obj = { a: 1 }; const obj2 = obj; obj2.a = 2; console.log(obj.a);",
		"options": [
			{
			"id": "a",
			"text": "1"
			},
			{
			"id": "b",
			"text": "2"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Объекты в JavaScript передаются по ссылке. obj2 и obj указывают на один и тот же объект, поэтому изменение obj2.a также изменяет obj.a."
		},
		{
		"id": "arrays-objects-5",
		"question": "Какой метод массива используется для проверки, удовлетворяют ли все элементы условию?",
		"options": [
			{
			"id": "a",
			"text": "some()"
			},
			{
			"id": "b",
			"text": "every()"
			},
			{
			"id": "c",
			"text": "filter()"
			},
			{
			"id": "d",
			"text": "find()"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Возвращает true, если все элементы проходят проверку."
		},
		{
		"id": "arrays-objects-6",
		"question": "Что делает метод reduce() в массиве?",
		"options": [
			{
			"id": "a",
			"text": "Уменьшает размер массива"
			},
			{
			"id": "b",
			"text": "Преобразует массив в одно значение, применяя функцию к каждому элементу и аккумулятору"
			},
			{
			"id": "c",
			"text": "Удаляет элементы из массива"
			},
			{
			"id": "d",
			"text": "Сортирует массив"
			}
		],
		"correctAnswerId": "b",
		"explanation": "reduce() применяет функцию к каждому элементу массива слева направо, накапливая результат в аккумуляторе. Возвращает одно итоговое значение."
		},
		{
		"id": "arrays-objects-7",
		"question": "Что такое shallow copy (поверхностное копирование) объекта?",
		"options": [
			{
			"id": "a",
			"text": "Копирование только примитивных свойств, вложенные объекты остаются ссылками"
			},
			{
			"id": "b",
			"text": "Полное копирование всех свойств, включая вложенные объекты"
			},
			{
			"id": "c",
			"text": "Удаление свойств объекта"
			},
			{
			"id": "d",
			"text": "Способ создания объекта"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Shallow copy создает новый объект, но вложенные объекты и массивы остаются ссылками на оригинальные. Методы: Object.assign(), spread operator {...obj}."
		},
		{
		"id": "arrays-objects-8",
		"question": "Что выведет: const arr = [1, 2, 3]; console.log(arr.slice(1, 2));",
		"options": [
			{
			"id": "a",
			"text": "[1, 2]"
			},
			{
			"id": "b",
			"text": "[2]"
			},
			{
			"id": "c",
			"text": "[2, 3]"
			},
			{
			"id": "d",
			"text": "[1]"
			}
		],
		"correctAnswerId": "b",
		"explanation": "slice(1, 2) возвращает новый массив с элементами от индекса 1 (включительно) до индекса 2 (не включительно), то есть только элемент с индексом 1 - [2]."
		},
		{
		"id": "arrays-objects-9",
		"question": "В чем разница между Object.keys() и Object.values()?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "Object.keys() возвращает массив ключей, Object.values() возвращает массив значений"
			},
			{
			"id": "c",
			"text": "Object.keys() возвращает значения, Object.values() возвращает ключи"
			},
			{
			"id": "d",
			"text": "Оба метода возвращают ключи"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Object.keys(obj) возвращает массив строковых ключей объекта. Object.values(obj) возвращает массив значений свойств объекта."
		},
		{
		"id": "arrays-objects-10",
		"question": "Что такое Set в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Коллекция уникальных значений, где каждое значение может встречаться только один раз"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных для работы с DOM"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Set - это коллекция уникальных значений. Автоматически удаляет дубликаты. Методы: add(), delete(), has(), size. Полезен для работы с уникальными значениями."
		},
		{
		"id": "arrays-objects-11",
		"question": "Что такое Map в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Метод массива для преобразования элементов"
			},
			{
			"id": "b",
			"text": "Коллекция пар ключ-значение, где ключи могут быть любого типа"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Способ объявления переменных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Map - это коллекция пар ключ-значение, где ключи могут быть любого типа (в отличие от объектов, где ключи только строки). Методы: set(), get(), has(), delete()."
		},
		{
		"id": "arrays-objects-12",
		"question": "Что выведет: const obj = { a: 1, b: 2 }; const { a, ...rest } = obj; console.log(rest);",
		"options": [
			{
			"id": "a",
			"text": "{ a: 1, b: 2 }"
			},
			{
			"id": "b",
			"text": "{ b: 2 }"
			},
			{
			"id": "c",
			"text": "{ a: 1 }"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Rest оператор (...) в деструктуризации собирает оставшиеся свойства в новый объект. Здесь извлекается a, а rest содержит все остальные свойства - { b: 2 }."
		}
	]
	},
	{
	"id": "oop",
	"title": "ООП",
	"questions": [
		{
		"id": "oop-1",
		"question": "Что такое прототип (prototype) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления класса"
			},
			{
			"id": "b",
			"text": "Механизм наследования, где объекты могут наследовать свойства и методы от других объектов"
			},
			{
			"id": "c",
			"text": "Встроенный объект JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Прототип - это механизм, с помощью которого объекты JavaScript наследуют свойства и методы от других объектов. Каждый объект имеет ссылку на свой прототип."
		},
		{
		"id": "oop-2",
		"question": "В чем разница между class и function constructor в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы, это синтаксический сахар"
			},
			{
			"id": "b",
			"text": "class - это синтаксический сахар над прототипным наследованием, но с дополнительными проверками"
			},
			{
			"id": "c",
			"text": "class работает быстрее"
			},
			{
			"id": "d",
			"text": "function constructor устарел и не используется"
			}
		],
		"correctAnswerId": "b",
		"explanation": "class в ES6 - это синтаксический сахар над прототипным наследованием. Под капотом используется тот же механизм, но с более строгими правилами (например, нельзя вызвать без new)."
		},
		{
		"id": "oop-3",
		"question": "Что такое this в контексте класса?",
		"options": [
			{
			"id": "a",
			"text": "Всегда указывает на глобальный объект"
			},
			{
			"id": "b",
			"text": "Указывает на экземпляр класса (instance)"
			},
			{
			"id": "c",
			"text": "Всегда undefined"
			},
			{
			"id": "d",
			"text": "Указывает на сам класс"
			}
		],
		"correctAnswerId": "b",
		"explanation": "В методах класса this указывает на экземпляр класса, для которого был вызван метод. Это позволяет обращаться к свойствам и методам конкретного экземпляра."
		},
		{
		"id": "oop-4",
		"question": "Что такое статический метод (static method) в классе?",
		"options": [
			{
			"id": "a",
			"text": "Метод, который нельзя вызвать"
			},
			{
			"id": "b",
			"text": "Метод, который принадлежит классу, а не экземпляру, и вызывается через имя класса"
			},
			{
			"id": "c",
			"text": "Метод, который работает только с одним экземпляром"
			},
			{
			"id": "d",
			"text": "Устаревший способ объявления методов"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Статический метод принадлежит самому классу, а не его экземплярам. Он вызывается через имя класса (ClassName.method()), а не через экземпляр."
		},
		{
		"id": "oop-5",
		"question": "Что такое инкапсуляция в контексте JavaScript классов?",
		"options": [
			{
			"id": "a",
			"text": "Способ скрытия деталей реализации через private поля и методы"
			},
			{
			"id": "b",
			"text": "Способ создания классов"
			},
			{
			"id": "c",
			"text": "Способ наследования"
			},
			{
			"id": "d",
			"text": "В JavaScript нет инкапсуляции"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Инкапсуляция - это принцип ООП, позволяющий скрыть детали реализации. В JavaScript (ES2022+) это реализуется через private поля (#field) и методы."
		},
		{
		"id": "oop-6",
		"question": "Что такое наследование (inheritance) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Механизм, при котором класс может наследовать свойства и методы от другого класса"
			},
			{
			"id": "b",
			"text": "Способ создания объектов"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Наследование позволяет классу (дочернему) наследовать свойства и методы от другого класса (родительского). В JavaScript реализуется через extends и super."
		},
		{
		"id": "oop-7",
		"question": "Что такое полиморфизм в контексте JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления классов"
			},
			{
			"id": "b",
			"text": "Способность объектов разных классов обрабатываться через один и тот же интерфейс"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Полиморфизм - это способность объектов разных классов обрабатываться через единый интерфейс. В JavaScript это реализуется через переопределение методов в дочерних классах."
		},
		{
		"id": "oop-8",
		"question": "Что такое getter и setter в классе?",
		"options": [
			{
			"id": "a",
			"text": "Способы объявления переменных"
			},
			{
			"id": "b",
			"text": "Специальные методы для получения и установки значений свойств с дополнительной логикой"
			},
			{
			"id": "c",
			"text": "Встроенные функции JavaScript"
			},
			{
			"id": "d",
			"text": "Типы данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Getter и setter - это методы, которые позволяют контролировать доступ к свойствам объекта. getter вызывается при чтении, setter - при записи. Синтаксис: get property() {} и set property(value) {}."
		},
		{
		"id": "oop-9",
		"question": "Что такое super в контексте классов?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Ключевое слово для вызова методов и конструктора родительского класса"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "super используется для вызова конструктора родительского класса (super()) или методов родительского класса (super.method()). Обязательно используется в конструкторе дочернего класса перед this."
		},
		{
		"id": "oop-10",
		"question": "Что такое mixin в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления класса"
			},
			{
			"id": "b",
			"text": "Паттерн, позволяющий добавлять методы и свойства в класс без наследования"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Mixin - это паттерн, который позволяет добавлять функциональность в класс без использования наследования. Обычно реализуется через Object.assign() или spread operator."
		},
		{
		"id": "oop-11",
		"question": "Что такое абстрактный класс в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Класс, который нельзя создать напрямую, только через наследование"
			},
			{
			"id": "b",
			"text": "Способ объявления класса"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "В JavaScript нет нативной поддержки абстрактных классов, но можно эмулировать через throw в конструкторе или через проверки. Абстрактный класс предназначен для наследования, а не для создания экземпляров."
		},
		{
		"id": "oop-12",
		"question": "Что такое композиция vs наследование?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "Композиция - включение объектов в другие объекты, наследование - создание иерархии классов"
			},
			{
			"id": "c",
			"text": "Композиция устарела, используется только наследование"
			},
			{
			"id": "d",
			"text": "Оба способа одинаковы"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Композиция - это включение объектов в другие объекты (has-a relationship). Наследование - создание иерархии классов (is-a relationship). Композиция часто предпочтительнее из-за большей гибкости."
		}
	]
	},
	{
	"id": "async",
	"title": "Асинхронность",
	"questions": [
		{
		"id": "async-1",
		"question": "Что такое Promise в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Встроенная функция для работы с массивами"
			},
			{
			"id": "b",
			"text": "Объект, представляющий результат асинхронной операции (успешной или неудачной)"
			},
			{
			"id": "c",
			"text": "Способ объявления переменных"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise - это объект, который представляет результат асинхронной операции. Он может находиться в состоянии pending, fulfilled (resolved) или rejected."
		},
		{
		"id": "async-2",
		"question": "Что выведет: console.log('1'); setTimeout(() => console.log('2'), 0); console.log('3');",
		"options": [
			{
			"id": "a",
			"text": "1, 2, 3"
			},
			{
			"id": "b",
			"text": "1, 3, 2"
			},
			{
			"id": "c",
			"text": "2, 1, 3"
			},
			{
			"id": "d",
			"text": "3, 1, 2"
			}
		],
		"correctAnswerId": "b",
		"explanation": "setTimeout добавляет callback в очередь событий (event queue), который выполнится после завершения текущего стека вызовов. Поэтому сначала выполнится синхронный код (1, 3), затем асинхронный (2)."
		},
		{
		"id": "async-3",
		"question": "В чем разница между async/await и Promise.then()?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы, это синтаксический сахар"
			},
			{
			"id": "b",
			"text": "async/await - синтаксический сахар над Promise, делает асинхронный код похожим на синхронный"
			},
			{
			"id": "c",
			"text": "Promise.then() работает быстрее"
			},
			{
			"id": "d",
			"text": "async/await устарел"
			}
		],
		"correctAnswerId": "b",
		"explanation": "async/await - это синтаксический сахар над Promise, который позволяет писать асинхронный код в более читаемом, синхронном стиле. Под капотом все равно используются Promise."
		},
		{
		"id": "async-4",
		"question": "Что такое event loop в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Цикл обработки событий, который управляет выполнением асинхронного кода"
			},
			{
			"id": "b",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "c",
			"text": "Способ создания событий"
			},
			{
			"id": "d",
			"text": "Тип данных для работы с событиями"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Event loop - это механизм, который управляет выполнением кода, сбором и обработкой событий, и выполнением подзадач в очереди. Он позволяет JavaScript выполнять неблокирующие операции."
		},
		{
		"id": "async-5",
		"question": "Что делает метод Promise.all()?",
		"options": [
			{
			"id": "a",
			"text": "Выполняет все Promise последовательно"
			},
			{
			"id": "b",
			"text": "Ожидает выполнения всех Promise и возвращает массив результатов, или отклоняется при первой ошибке"
			},
			{
			"id": "c",
			"text": "Выполняет только первый успешный Promise"
			},
			{
			"id": "d",
			"text": "Отменяет все Promise"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise.all() принимает массив Promise и возвращает новый Promise, который разрешается, когда все Promise разрешены, или отклоняется, если хотя бы один Promise отклонен."
		},
		{
		"id": "async-6",
		"question": "Что такое Promise.race()?",
		"options": [
			{
			"id": "a",
			"text": "Ожидает выполнения всех Promise"
			},
			{
			"id": "b",
			"text": "Возвращает Promise, который разрешается или отклоняется, как только первый Promise в массиве разрешается или отклоняется"
			},
			{
			"id": "c",
			"text": "Отменяет все Promise"
			},
			{
			"id": "d",
			"text": "Выполняет Promise последовательно"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise.race() возвращает Promise, который разрешается или отклоняется, как только первый Promise в массиве разрешается или отклоняется. Полезен для таймаутов."
		},
		{
		"id": "async-7",
		"question": "Что такое Promise.allSettled()?",
		"options": [
			{
			"id": "a",
			"text": "Ожидает выполнения всех Promise, но не отклоняется при ошибках"
			},
			{
			"id": "b",
			"text": "Возвращает Promise, который разрешается после завершения всех Promise, независимо от их результата"
			},
			{
			"id": "c",
			"text": "Отменяет все Promise"
			},
			{
			"id": "d",
			"text": "Выполняет только первый Promise"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise.allSettled() возвращает Promise, который разрешается после завершения всех Promise в массиве, независимо от того, разрешены они или отклонены. Результат - массив объектов с status и value/reason."
		},
		{
		"id": "async-8",
		"question": "Что такое генератор (generator) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Функция, которая может приостанавливать выполнение и возобновлять его позже, используя yield"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Генератор - это функция, объявленная через function*, которая может приостанавливать выполнение с помощью yield и возобновлять его через next(). Полезен для создания итераторов и работы с асинхронностью."
		},
		{
		"id": "async-9",
		"question": "Что такое async generator?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Генератор, который может использовать await внутри yield"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Async generator - это функция async function*, которая может использовать await и yield. Позволяет создавать асинхронные итераторы для работы с потоками данных."
		},
		{
		"id": "async-10",
		"question": "Что такое Web Workers?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Механизм для выполнения JavaScript кода в фоновом потоке, не блокируя основной поток"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Web Workers позволяют выполнять JavaScript код в отдельном потоке, не блокируя основной поток браузера. Полезны для тяжелых вычислений. Общение через postMessage."
		},
		{
		"id": "async-11",
		"question": "Что такое callback hell?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функций"
			},
			{
			"id": "b",
			"text": "Проблема глубоко вложенных callback функций, делающая код трудным для чтения и поддержки"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Callback hell - это ситуация, когда множество вложенных callback функций создают пирамиду кода, которую трудно читать и поддерживать. Решается через Promise и async/await."
		},
		{
		"id": "async-12",
		"question": "Что такое debounce и throttle?",
		"options": [
			{
			"id": "a",
			"text": "Способы объявления функций"
			},
			{
			"id": "b",
			"text": "Техники ограничения частоты вызова функции: debounce - задержка выполнения, throttle - ограничение частоты"
			},
			{
			"id": "c",
			"text": "Встроенные функции JavaScript"
			},
			{
			"id": "d",
			"text": "Типы данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Debounce откладывает выполнение функции до тех пор, пока не пройдет определенное время без новых вызовов. Throttle ограничивает частоту вызовов функции, выполняя ее максимум раз в определенный интервал."
		}
	]
	},
	{
	"id": "dom-events",
	"title": "DOM и события",
	"questions": [
		{
		"id": "dom-events-1",
		"question": "Что такое DOM?",
		"options": [
			{
			"id": "a",
			"text": "Document Object Model - представление HTML документа в виде дерева объектов"
			},
			{
			"id": "b",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "c",
			"text": "Способ работы с CSS"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "DOM (Document Object Model) - это программный интерфейс для HTML и XML документов. Он представляет структуру документа в виде дерева объектов, которые можно изменять."
		},
		{
		"id": "dom-events-2",
		"question": "В чем разница между addEventListener и onclick?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "addEventListener позволяет добавить несколько обработчиков, onclick перезаписывает предыдущий"
			},
			{
			"id": "c",
			"text": "onclick работает быстрее"
			},
			{
			"id": "d",
			"text": "addEventListener устарел"
			}
		],
		"correctAnswerId": "b",
		"explanation": "addEventListener позволяет добавить несколько обработчиков событий к одному элементу. onclick - это свойство, которое можно установить только один раз, новое значение перезапишет предыдущее."
		},
		{
		"id": "dom-events-3",
		"question": "Что такое event bubbling?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "Механизм, при котором событие распространяется от целевого элемента вверх по дереву DOM к корню"
			},
			{
			"id": "c",
			"text": "Способ остановки событий"
			},
			{
			"id": "d",
			"text": "Тип события"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Event bubbling - это механизм, при котором событие сначала обрабатывается на целевом элементе, а затем распространяется вверх по дереву DOM к родительским элементам."
		},
		{
		"id": "dom-events-4",
		"question": "Как остановить всплытие события (event bubbling)?",
		"options": [
			{
			"id": "a",
			"text": "event.stopPropagation()"
			},
			{
			"id": "b",
			"text": "event.preventDefault()"
			},
			{
			"id": "c",
			"text": "event.stop()"
			},
			{
			"id": "d",
			"text": "event.cancel()"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Метод event.stopPropagation() останавливает дальнейшее распространение события в фазе всплытия или перехвата. event.preventDefault() предотвращает стандартное поведение элемента."
		},
		{
		"id": "dom-events-5",
		"question": "Что такое event delegation?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "Техника, при которой обработчик события привязывается к родительскому элементу вместо множества дочерних"
			},
			{
			"id": "c",
			"text": "Удаление событий"
			},
			{
			"id": "d",
			"text": "Тип события"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Event delegation - это техника, при которой один обработчик события привязывается к родительскому элементу, а не к каждому дочернему элементу отдельно. Это эффективно для динамически добавляемых элементов."
		},
		{
		"id": "dom-events-6",
		"question": "Что такое event capturing (перехват событий)?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "Фаза события, при которой событие распространяется от корня DOM к целевому элементу"
			},
			{
			"id": "c",
			"text": "Удаление событий"
			},
			{
			"id": "d",
			"text": "Тип события"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Event capturing - это фаза события, при которой событие распространяется от корня документа к целевому элементу. В addEventListener можно включить через третий параметр { capture: true }."
		},
		{
		"id": "dom-events-7",
		"question": "Что такое Virtual DOM?",
		"options": [
			{
			"id": "a",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "b",
			"text": "Легковесное представление реального DOM в памяти, используемое для оптимизации обновлений"
			},
			{
			"id": "c",
			"text": "Способ работы с DOM"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Virtual DOM - это концепция, при которой создается легковесная копия реального DOM в памяти. Изменения сначала применяются к Virtual DOM, затем сравниваются с реальным DOM и обновляются только различия (diffing)."
		},
		{
		"id": "dom-events-8",
		"question": "Что такое MutationObserver?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "API для наблюдения за изменениями в DOM дереве"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "MutationObserver позволяет асинхронно отслеживать изменения в DOM (добавление, удаление узлов, изменение атрибутов). Более эффективная альтернатива устаревшему MutationEvents."
		},
		{
		"id": "dom-events-9",
		"question": "Что такое passive event listeners?",
		"options": [
			{
			"id": "a",
			"text": "Слушатели, которые не могут быть отменены"
			},
			{
			"id": "b",
			"text": "Слушатели, которые указывают, что обработчик никогда не вызовет preventDefault(), улучшая производительность прокрутки"
			},
			{
			"id": "c",
			"text": "Встроенные функции JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Passive event listeners ({ passive: true }) указывают, что обработчик никогда не вызовет preventDefault(). Это позволяет браузеру оптимизировать прокрутку, не ожидая выполнения обработчика."
		},
		{
		"id": "dom-events-10",
		"question": "Что такое requestAnimationFrame?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания анимаций"
			},
			{
			"id": "b",
			"text": "API для выполнения функции перед следующей перерисовкой браузера, оптимизируя анимации"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "requestAnimationFrame планирует выполнение функции перед следующей перерисовкой браузера (обычно 60 раз в секунду). Оптимизирует анимации, синхронизируя их с частотой обновления экрана."
		},
		{
		"id": "dom-events-11",
		"question": "Что такое CustomEvent?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "API для создания и диспетчеризации пользовательских событий"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "CustomEvent позволяет создавать и диспетчеризировать пользовательские события с дополнительными данными. Полезно для коммуникации между компонентами. Синтаксис: new CustomEvent('eventName', { detail: data })."
		},
		{
		"id": "dom-events-12",
		"question": "Что такое IntersectionObserver?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "API для асинхронного наблюдения за пересечением элемента с viewport или другим элементом"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "IntersectionObserver позволяет эффективно отслеживать, когда элемент входит или выходит из viewport. Полезен для ленивой загрузки изображений, бесконечной прокрутки, аналитики видимости."
		}
	]
	},
	{
	"id": "es6-plus",
	"title": "ES6+",
	"questions": [
		{
		"id": "es6-plus-1",
		"question": "В чем разница между let, const и var?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "let и const имеют блочную область видимости, var - функциональную. const нельзя переприсвоить"
			},
			{
			"id": "c",
			"text": "var работает быстрее"
			},
			{
			"id": "d",
			"text": "let и const устарели"
			}
		],
		"correctAnswerId": "b",
		"explanation": "let и const имеют блочную область видимости (block scope), var - функциональную (function scope). const нельзя переприсвоить после инициализации, но можно изменять содержимое объектов/массивов."
		},
		{
		"id": "es6-plus-2",
		"question": "Что такое template literals (шаблонные строки)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Строки, позволяющие встраивать выражения через ${} и многострочный текст"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Template literals (обратные кавычки `) позволяют создавать строки с встроенными выражениями через ${expression} и поддерживают многострочный текст без конкатенации."
		},
		{
		"id": "es6-plus-3",
		"question": "Что такое spread operator (...) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Оператор, который позволяет разворачивать элементы массива или свойства объекта"
			},
			{
			"id": "c",
			"text": "Встроенная функция"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Spread operator (...) позволяет разворачивать элементы массива или свойства объекта. Используется для копирования массивов/объектов, передачи аргументов в функции, объединения массивов и т.д."
		},
		{
		"id": "es6-plus-4",
		"question": "Что такое arrow function (стрелочная функция)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления обычной функции"
			},
			{
			"id": "b",
			"text": "Сокращенный синтаксис функции, который не имеет собственного this и не может быть конструктором"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Arrow function - это сокращенный синтаксис функции (() => {}). Не имеет собственного this (наследует из лексического контекста), arguments, и не может быть использована как конструктор."
		},
		{
		"id": "es6-plus-5",
		"question": "Что такое модули ES6 (import/export)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Система модулей для организации и переиспользования кода между файлами"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "ES6 модули позволяют экспортировать (export) и импортировать (import) функции, классы, переменные и другие сущности между файлами. Это стандартный способ организации кода в современных JavaScript приложениях."
		},
		{
		"id": "es6-plus-6",
		"question": "Что такое default параметры в функциях?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функций"
			},
			{
			"id": "b",
			"text": "Параметры функции, которые имеют значения по умолчанию, если аргумент не передан"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Default параметры позволяют задавать значения по умолчанию для параметров функции. Если аргумент не передан или равен undefined, используется значение по умолчанию. Синтаксис: function foo(a = 1, b = 2) {}."
		},
		{
		"id": "es6-plus-7",
		"question": "Что такое rest параметры в функциях?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функций"
			},
			{
			"id": "b",
			"text": "Параметр, который собирает оставшиеся аргументы в массив"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Rest параметры (синтаксис ...rest) собирают оставшиеся аргументы функции в массив. Должен быть последним параметром. Пример: function foo(a, b, ...rest) {} - rest будет массивом всех аргументов после b."
		},
		{
		"id": "es6-plus-8",
		"question": "Что такое Symbol в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Примитивный тип данных, создающий уникальные идентификаторы"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных для работы с DOM"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Symbol - это примитивный тип данных, который создает уникальные идентификаторы. Каждый Symbol уникален, даже если создан с тем же описанием. Полезен для создания скрытых свойств объектов."
		},
		{
		"id": "es6-plus-9",
		"question": "Что такое Proxy в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Объект, который перехватывает операции с другим объектом (доступ к свойствам, вызовы методов)"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Proxy позволяет перехватывать и переопределять операции с объектом (get, set, has, delete и др.). Полезен для валидации, логирования, создания реактивных систем. Синтаксис: new Proxy(target, handler)."
		},
		{
		"id": "es6-plus-10",
		"question": "Что такое WeakMap и WeakSet?",
		"options": [
			{
			"id": "a",
			"text": "Способы объявления переменных"
			},
			{
			"id": "b",
			"text": "Коллекции с слабыми ссылками, позволяющие объектам быть удаленными сборщиком мусора"
			},
			{
			"id": "c",
			"text": "Встроенные функции JavaScript"
			},
			{
			"id": "d",
			"text": "Типы данных для работы с DOM"
			}
		],
		"correctAnswerId": "b",
		"explanation": "WeakMap и WeakSet - это коллекции с слабыми ссылками на ключи. Если объект-ключ больше не используется, он может быть удален сборщиком мусора. Ключи могут быть только объектами, не примитивами."
		},
		{
		"id": "es6-plus-11",
		"question": "Что такое Optional Chaining (?.)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Оператор для безопасного доступа к свойствам вложенных объектов, возвращающий undefined вместо ошибки"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Optional Chaining (?.) позволяет безопасно обращаться к свойствам вложенных объектов. Если любое звено в цепочке равно null или undefined, возвращается undefined вместо ошибки. Пример: obj?.prop?.nested."
		},
		{
		"id": "es6-plus-12",
		"question": "Что такое Nullish Coalescing (??)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Оператор, возвращающий правый операнд, если левый равен null или undefined"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Nullish Coalescing (??) возвращает правый операнд, если левый равен null или undefined. В отличие от ||, не возвращает правый операнд для falsy значений (0, '', false). Пример: value ?? defaultValue."
		}
	]
	}
]
}

