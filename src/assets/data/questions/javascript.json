{
"language": "javascript",
"sections": [
	{
	"id": "basics",
	"title": "Основы",
	"questions": [
		{
		"id": "basics-1",
		"question": "Что выведет следующий код: console.log(typeof null)?",
		"options": [
			{
			"id": "a",
			"text": "null"
			},
			{
			"id": "b",
			"text": "object"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "boolean"
			}
		],
		"correctAnswerId": "b",
		"explanation": "typeof null возвращает 'object' - это известная особенность JavaScript, которая является багом в языке."
		},
		{
		"id": "basics-2",
		"question": "Какое значение имеет переменная после выполнения: let x = 10; x = '20';?",
		"options": [
			{
			"id": "a",
			"text": "10"
			},
			{
			"id": "b",
			"text": "20"
			},
			{
			"id": "c",
			"text": "'20'"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "c",
		"explanation": "JavaScript - язык с динамической типизацией, переменная x сначала была числом 10, затем стала строкой '20'."
		},
		{
		"id": "basics-3",
		"question": "Что такое hoisting в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Поднятие объявлений переменных и функций в начало области видимости"
			},
			{
			"id": "b",
			"text": "Оптимизация кода компилятором"
			},
			{
			"id": "c",
			"text": "Удаление неиспользуемого кода"
			},
			{
			"id": "d",
			"text": "Кэширование результатов функций"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Hoisting - это механизм JavaScript, при котором объявления переменных (var) и функций поднимаются в начало их области видимости."
		},
		{
		"id": "basics-4",
		"question": "Чему равно значение: 0.1 + 0.2 === 0.3?",
		"options": [
			{
			"id": "a",
			"text": "true"
			},
			{
			"id": "b",
			"text": "false"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Из-за особенностей представления чисел с плавающей точкой в JavaScript, 0.1 + 0.2 не равно точно 0.3, а примерно 0.30000000000000004."
		},
		{
		"id": "basics-5",
		"question": "Какая разница между == и === в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "== сравнивает значения с приведением типов, === сравнивает значения и типы"
			},
			{
			"id": "c",
			"text": "== сравнивает ссылки, === сравнивает значения"
			},
			{
			"id": "d",
			"text": "== работает только с числами, === работает со всеми типами"
			}
		],
		"correctAnswerId": "b",
		"explanation": "== выполняет приведение типов перед сравнением (например, '5' == 5 вернет true), а === сравнивает без приведения типов ('5' === 5 вернет false)."
		}
	]
	},
	{
	"id": "functions",
	"title": "Функции",
	"questions": [
		{
		"id": "functions-1",
		"question": "Что такое замыкание (closure) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления функции"
			},
			{
			"id": "b",
			"text": "Функция, которая имеет доступ к переменным из внешней области видимости"
			},
			{
			"id": "c",
			"text": "Способ вызова функции"
			},
			{
			"id": "d",
			"text": "Встроенная функция JavaScript"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Замыкание - это функция, которая имеет доступ к переменным из внешней (охватывающей) области видимости, даже после того, как внешняя функция завершила выполнение."
		},
		{
		"id": "functions-2",
		"question": "Что выведет код: function test() { return this; } console.log(test());",
		"options": [
			{
			"id": "a",
			"text": "undefined"
			},
			{
			"id": "b",
			"text": "null"
			},
			{
			"id": "c",
			"text": "window (в браузере) или global (в Node.js)"
			},
			{
			"id": "d",
			"text": "Сама функция test"
			}
		],
		"correctAnswerId": "c",
		"explanation": "В обычном режиме (не strict mode) this в функции, вызванной без контекста, указывает на глобальный объект (window в браузере, global в Node.js)."
		},
		{
		"id": "functions-3",
		"question": "В чем разница между function declaration и function expression?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "Function declaration поднимается (hoisted), function expression - нет"
			},
			{
			"id": "c",
			"text": "Function expression поднимается, function declaration - нет"
			},
			{
			"id": "d",
			"text": "Function declaration нельзя вызывать, function expression можно"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Function declaration поднимается в начало области видимости и может быть вызвана до объявления. Function expression создается только при выполнении строки кода."
		},
		{
		"id": "functions-4",
		"question": "Что такое IIFE (Immediately Invoked Function Expression)?",
		"options": [
			{
			"id": "a",
			"text": "Функция, которая вызывается автоматически при загрузке страницы"
			},
			{
			"id": "b",
			"text": "Функция, которая выполняется немедленно после определения"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Асинхронная функция"
			}
		],
		"correctAnswerId": "b",
		"explanation": "IIFE - это функция, которая выполняется сразу же после создания. Синтаксис: (function() { ... })() или (function() { ... }())."
		},
		{
		"id": "functions-5",
		"question": "Что выведет: const arrow = () => { return this; }; console.log(arrow());",
		"options": [
			{
			"id": "a",
			"text": "undefined"
			},
			{
			"id": "b",
			"text": "window или global"
			},
			{
			"id": "c",
			"text": "this берется из лексического контекста (где функция определена)"
			},
			{
			"id": "d",
			"text": "null"
			}
		],
		"correctAnswerId": "c",
		"explanation": "Стрелочные функции не имеют собственного this. Они наследуют this из окружающего лексического контекста, где они были определены."
		}
	]
	},
	{
	"id": "arrays-objects",
	"title": "Массивы и объекты",
	"questions": [
		{
		"id": "arrays-objects-1",
		"question": "Что выведет: const arr = [1, 2, 3]; arr[10] = 10; console.log(arr.length);",
		"options": [
			{
			"id": "a",
			"text": "3"
			},
			{
			"id": "b",
			"text": "4"
			},
			{
			"id": "c",
			"text": "11"
			},
			{
			"id": "d",
			"text": "10"
			}
		],
		"correctAnswerId": "c",
		"explanation": "При присваивании значения по индексу 10, длина массива становится 11 (индексы от 0 до 10). Элементы с индексами 3-9 будут undefined."
		},
		{
		"id": "arrays-objects-2",
		"question": "В чем разница между методами map() и forEach()?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "map() возвращает новый массив, forEach() возвращает undefined"
			},
			{
			"id": "c",
			"text": "forEach() возвращает новый массив, map() возвращает undefined"
			},
			{
			"id": "d",
			"text": "map() изменяет исходный массив, forEach() создает новый"
			}
		],
		"correctAnswerId": "b",
		"explanation": "map() создает и возвращает новый массив с результатами вызова функции для каждого элемента. forEach() просто выполняет функцию для каждого элемента и возвращает undefined."
		},
		{
		"id": "arrays-objects-3",
		"question": "Что такое деструктуризация (destructuring) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Удаление элементов из массива"
			},
			{
			"id": "b",
			"text": "Способ извлечения значений из массивов или объектов в отдельные переменные"
			},
			{
			"id": "c",
			"text": "Способ создания объектов"
			},
			{
			"id": "d",
			"text": "Метод работы с DOM"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Деструктуризация позволяет извлекать значения из массивов или свойств объектов в отдельные переменные. Пример: const [a, b] = [1, 2]; или const {name, age} = person;"
		},
		{
		"id": "arrays-objects-4",
		"question": "Что выведет: const obj = { a: 1 }; const obj2 = obj; obj2.a = 2; console.log(obj.a);",
		"options": [
			{
			"id": "a",
			"text": "1"
			},
			{
			"id": "b",
			"text": "2"
			},
			{
			"id": "c",
			"text": "undefined"
			},
			{
			"id": "d",
			"text": "Ошибка"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Объекты в JavaScript передаются по ссылке. obj2 и obj указывают на один и тот же объект, поэтому изменение obj2.a также изменяет obj.a."
		},
		{
		"id": "arrays-objects-5",
		"question": "Какой метод массива используется для проверки, удовлетворяют ли все элементы условию?",
		"options": [
			{
			"id": "a",
			"text": "some()"
			},
			{
			"id": "b",
			"text": "every()"
			},
			{
			"id": "c",
			"text": "filter()"
			},
			{
			"id": "d",
			"text": "find()"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Возвращает true, если все элементы проходят проверку."
		}
	]
	},
	{
	"id": "oop",
	"title": "ООП",
	"questions": [
		{
		"id": "oop-1",
		"question": "Что такое прототип (prototype) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления класса"
			},
			{
			"id": "b",
			"text": "Механизм наследования, где объекты могут наследовать свойства и методы от других объектов"
			},
			{
			"id": "c",
			"text": "Встроенный объект JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Прототип - это механизм, с помощью которого объекты JavaScript наследуют свойства и методы от других объектов. Каждый объект имеет ссылку на свой прототип."
		},
		{
		"id": "oop-2",
		"question": "В чем разница между class и function constructor в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы, это синтаксический сахар"
			},
			{
			"id": "b",
			"text": "class - это синтаксический сахар над прототипным наследованием, но с дополнительными проверками"
			},
			{
			"id": "c",
			"text": "class работает быстрее"
			},
			{
			"id": "d",
			"text": "function constructor устарел и не используется"
			}
		],
		"correctAnswerId": "b",
		"explanation": "class в ES6 - это синтаксический сахар над прототипным наследованием. Под капотом используется тот же механизм, но с более строгими правилами (например, нельзя вызвать без new)."
		},
		{
		"id": "oop-3",
		"question": "Что такое this в контексте класса?",
		"options": [
			{
			"id": "a",
			"text": "Всегда указывает на глобальный объект"
			},
			{
			"id": "b",
			"text": "Указывает на экземпляр класса (instance)"
			},
			{
			"id": "c",
			"text": "Всегда undefined"
			},
			{
			"id": "d",
			"text": "Указывает на сам класс"
			}
		],
		"correctAnswerId": "b",
		"explanation": "В методах класса this указывает на экземпляр класса, для которого был вызван метод. Это позволяет обращаться к свойствам и методам конкретного экземпляра."
		},
		{
		"id": "oop-4",
		"question": "Что такое статический метод (static method) в классе?",
		"options": [
			{
			"id": "a",
			"text": "Метод, который нельзя вызвать"
			},
			{
			"id": "b",
			"text": "Метод, который принадлежит классу, а не экземпляру, и вызывается через имя класса"
			},
			{
			"id": "c",
			"text": "Метод, который работает только с одним экземпляром"
			},
			{
			"id": "d",
			"text": "Устаревший способ объявления методов"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Статический метод принадлежит самому классу, а не его экземплярам. Он вызывается через имя класса (ClassName.method()), а не через экземпляр."
		},
		{
		"id": "oop-5",
		"question": "Что такое инкапсуляция в контексте JavaScript классов?",
		"options": [
			{
			"id": "a",
			"text": "Способ скрытия деталей реализации через private поля и методы"
			},
			{
			"id": "b",
			"text": "Способ создания классов"
			},
			{
			"id": "c",
			"text": "Способ наследования"
			},
			{
			"id": "d",
			"text": "В JavaScript нет инкапсуляции"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Инкапсуляция - это принцип ООП, позволяющий скрыть детали реализации. В JavaScript (ES2022+) это реализуется через private поля (#field) и методы."
		}
	]
	},
	{
	"id": "async",
	"title": "Асинхронность",
	"questions": [
		{
		"id": "async-1",
		"question": "Что такое Promise в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Встроенная функция для работы с массивами"
			},
			{
			"id": "b",
			"text": "Объект, представляющий результат асинхронной операции (успешной или неудачной)"
			},
			{
			"id": "c",
			"text": "Способ объявления переменных"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise - это объект, который представляет результат асинхронной операции. Он может находиться в состоянии pending, fulfilled (resolved) или rejected."
		},
		{
		"id": "async-2",
		"question": "Что выведет: console.log('1'); setTimeout(() => console.log('2'), 0); console.log('3');",
		"options": [
			{
			"id": "a",
			"text": "1, 2, 3"
			},
			{
			"id": "b",
			"text": "1, 3, 2"
			},
			{
			"id": "c",
			"text": "2, 1, 3"
			},
			{
			"id": "d",
			"text": "3, 1, 2"
			}
		],
		"correctAnswerId": "b",
		"explanation": "setTimeout добавляет callback в очередь событий (event queue), который выполнится после завершения текущего стека вызовов. Поэтому сначала выполнится синхронный код (1, 3), затем асинхронный (2)."
		},
		{
		"id": "async-3",
		"question": "В чем разница между async/await и Promise.then()?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы, это синтаксический сахар"
			},
			{
			"id": "b",
			"text": "async/await - синтаксический сахар над Promise, делает асинхронный код похожим на синхронный"
			},
			{
			"id": "c",
			"text": "Promise.then() работает быстрее"
			},
			{
			"id": "d",
			"text": "async/await устарел"
			}
		],
		"correctAnswerId": "b",
		"explanation": "async/await - это синтаксический сахар над Promise, который позволяет писать асинхронный код в более читаемом, синхронном стиле. Под капотом все равно используются Promise."
		},
		{
		"id": "async-4",
		"question": "Что такое event loop в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Цикл обработки событий, который управляет выполнением асинхронного кода"
			},
			{
			"id": "b",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "c",
			"text": "Способ создания событий"
			},
			{
			"id": "d",
			"text": "Тип данных для работы с событиями"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Event loop - это механизм, который управляет выполнением кода, сбором и обработкой событий, и выполнением подзадач в очереди. Он позволяет JavaScript выполнять неблокирующие операции."
		},
		{
		"id": "async-5",
		"question": "Что делает метод Promise.all()?",
		"options": [
			{
			"id": "a",
			"text": "Выполняет все Promise последовательно"
			},
			{
			"id": "b",
			"text": "Ожидает выполнения всех Promise и возвращает массив результатов, или отклоняется при первой ошибке"
			},
			{
			"id": "c",
			"text": "Выполняет только первый успешный Promise"
			},
			{
			"id": "d",
			"text": "Отменяет все Promise"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Promise.all() принимает массив Promise и возвращает новый Promise, который разрешается, когда все Promise разрешены, или отклоняется, если хотя бы один Promise отклонен."
		}
	]
	},
	{
	"id": "dom-events",
	"title": "DOM и события",
	"questions": [
		{
		"id": "dom-events-1",
		"question": "Что такое DOM?",
		"options": [
			{
			"id": "a",
			"text": "Document Object Model - представление HTML документа в виде дерева объектов"
			},
			{
			"id": "b",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "c",
			"text": "Способ работы с CSS"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "a",
		"explanation": "DOM (Document Object Model) - это программный интерфейс для HTML и XML документов. Он представляет структуру документа в виде дерева объектов, которые можно изменять."
		},
		{
		"id": "dom-events-2",
		"question": "В чем разница между addEventListener и onclick?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "addEventListener позволяет добавить несколько обработчиков, onclick перезаписывает предыдущий"
			},
			{
			"id": "c",
			"text": "onclick работает быстрее"
			},
			{
			"id": "d",
			"text": "addEventListener устарел"
			}
		],
		"correctAnswerId": "b",
		"explanation": "addEventListener позволяет добавить несколько обработчиков событий к одному элементу. onclick - это свойство, которое можно установить только один раз, новое значение перезапишет предыдущее."
		},
		{
		"id": "dom-events-3",
		"question": "Что такое event bubbling?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "Механизм, при котором событие распространяется от целевого элемента вверх по дереву DOM к корню"
			},
			{
			"id": "c",
			"text": "Способ остановки событий"
			},
			{
			"id": "d",
			"text": "Тип события"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Event bubbling - это механизм, при котором событие сначала обрабатывается на целевом элементе, а затем распространяется вверх по дереву DOM к родительским элементам."
		},
		{
		"id": "dom-events-4",
		"question": "Как остановить всплытие события (event bubbling)?",
		"options": [
			{
			"id": "a",
			"text": "event.stopPropagation()"
			},
			{
			"id": "b",
			"text": "event.preventDefault()"
			},
			{
			"id": "c",
			"text": "event.stop()"
			},
			{
			"id": "d",
			"text": "event.cancel()"
			}
		],
		"correctAnswerId": "a",
		"explanation": "Метод event.stopPropagation() останавливает дальнейшее распространение события в фазе всплытия или перехвата. event.preventDefault() предотвращает стандартное поведение элемента."
		},
		{
		"id": "dom-events-5",
		"question": "Что такое event delegation?",
		"options": [
			{
			"id": "a",
			"text": "Способ создания событий"
			},
			{
			"id": "b",
			"text": "Техника, при которой обработчик события привязывается к родительскому элементу вместо множества дочерних"
			},
			{
			"id": "c",
			"text": "Удаление событий"
			},
			{
			"id": "d",
			"text": "Тип события"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Event delegation - это техника, при которой один обработчик события привязывается к родительскому элементу, а не к каждому дочернему элементу отдельно. Это эффективно для динамически добавляемых элементов."
		}
	]
	},
	{
	"id": "es6-plus",
	"title": "ES6+",
	"questions": [
		{
		"id": "es6-plus-1",
		"question": "В чем разница между let, const и var?",
		"options": [
			{
			"id": "a",
			"text": "Нет разницы"
			},
			{
			"id": "b",
			"text": "let и const имеют блочную область видимости, var - функциональную. const нельзя переприсвоить"
			},
			{
			"id": "c",
			"text": "var работает быстрее"
			},
			{
			"id": "d",
			"text": "let и const устарели"
			}
		],
		"correctAnswerId": "b",
		"explanation": "let и const имеют блочную область видимости (block scope), var - функциональную (function scope). const нельзя переприсвоить после инициализации, но можно изменять содержимое объектов/массивов."
		},
		{
		"id": "es6-plus-2",
		"question": "Что такое template literals (шаблонные строки)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Строки, позволяющие встраивать выражения через ${} и многострочный текст"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Template literals (обратные кавычки `) позволяют создавать строки с встроенными выражениями через ${expression} и поддерживают многострочный текст без конкатенации."
		},
		{
		"id": "es6-plus-3",
		"question": "Что такое spread operator (...) в JavaScript?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Оператор, который позволяет разворачивать элементы массива или свойства объекта"
			},
			{
			"id": "c",
			"text": "Встроенная функция"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Spread operator (...) позволяет разворачивать элементы массива или свойства объекта. Используется для копирования массивов/объектов, передачи аргументов в функции, объединения массивов и т.д."
		},
		{
		"id": "es6-plus-4",
		"question": "Что такое arrow function (стрелочная функция)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления обычной функции"
			},
			{
			"id": "b",
			"text": "Сокращенный синтаксис функции, который не имеет собственного this и не может быть конструктором"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "Arrow function - это сокращенный синтаксис функции (() => {}). Не имеет собственного this (наследует из лексического контекста), arguments, и не может быть использована как конструктор."
		},
		{
		"id": "es6-plus-5",
		"question": "Что такое модули ES6 (import/export)?",
		"options": [
			{
			"id": "a",
			"text": "Способ объявления переменных"
			},
			{
			"id": "b",
			"text": "Система модулей для организации и переиспользования кода между файлами"
			},
			{
			"id": "c",
			"text": "Встроенная функция JavaScript"
			},
			{
			"id": "d",
			"text": "Тип данных"
			}
		],
		"correctAnswerId": "b",
		"explanation": "ES6 модули позволяют экспортировать (export) и импортировать (import) функции, классы, переменные и другие сущности между файлами. Это стандартный способ организации кода в современных JavaScript приложениях."
		}
	]
	}
]
}

